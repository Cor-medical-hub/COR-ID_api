
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="/static/favicon.png">
  <meta charset="UTF-8">
  <title>DICOM Viewer</title>
 
<link rel="stylesheet" type="text/css" href="/static/dicom_viewer.css">
<link rel="stylesheet" type="text/css" href="/static/styles.css">
<link rel="stylesheet" type="text/css" href="/static/modal.css">
</head>
<body>

  <div class="viewer">
    <div class="view">
      <label class="label-padded">Coronal</label> 
      <canvas id="canvas-coronal" width="512" height="512"></canvas>   
      <div class="dcm-range-container">
        <input type="range" id="coronal" min="0" max="100" value="50" 
               oninput="update('coronal'); updateSliderValue('coronal')">
        <span class="dcm-range-value">50</span>
      </div>
    </div>
    
    <div class="view">
      <label class="label-padded">Sagittal</label>
      <canvas id="canvas-sagittal" width="512" height="512"></canvas>     
      <div class="dcm-range-container">
        <input type="range" id="sagittal" min="0" max="100" value="50" 
               oninput="update('sagittal'); updateSliderValue('sagittal')">
        <span class="dcm-range-value">50</span>
      </div>
    </div>
   
    <div class="view">
      <label class="label-padded">Axial</label>
      <canvas id="canvas-axial" width="512" height="512"></canvas>
      <div class="dcm-range-container">
        <input type="range" id="axial" min="0" max="100" value="50" 
               oninput="update('axial'); updateSliderValue('axial')">
        <span class="dcm-range-value">50</span>
      </div>
    </div>

    <div class="dicom-upload-container">
      <input type="file" id="dicom-upload" accept=".zip,.dcm" multiple>
      <button onclick="handleUpload()">Upload DICOM files</button>
      <div class="dicom-progress-container">

          <div class="dicom-progress-bar" id="progress-bar">0%</div>
      </div>
      <div class="file-info" id="file-info"></div>
      <div id="upload-status"></div>


      <div class="metadata-container" id="metadata-container" style="display: none;">
        <h3 style="margin-top:5px;margin-bottom:5px;  color: #7527B2; font-size: 15px;">DICOM Metadata</h3>
        <div id="metadata-content"></div>
      </div>

      <div class="viewer-controls">
        <label>View Mode:
          <select id="view-mode" onchange="updateViewMode()">
            <option value="auto">Auto (Window Level)</option>
            <option value="window">Manual Window Level</option>
            <option value="raw">Raw Data</option>
          </select>
        </label>
        
        <div id="window-controls" style="display: none; margin-top: 10px;">
          <label>Window Center: <input type="range" id="window-center" min="0" max="3000" value="50" step="1"></label>
          <label>Window Width: <input type="range" id="window-width" min="0" max="3000" value="400" step="1"></label>
          <button onclick="applyManualWindow()">Apply</button>
        </div>
      </div>
  </div>


  </div>


  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  
  <script>
    let markers3D = [];

    let currentMode = 'auto';
    let manualWindowCenter = 50;
    let manualWindowWidth = 400;

    function updateViewMode() {
  currentMode = document.getElementById('view-mode').value;
  
  // Показываем/скрываем ручные контролы window level
  const windowControls = document.getElementById('window-controls');
  windowControls.style.display = currentMode === 'window' ? 'block' : 'none';
  
  // Обновляем все изображения
  ['axial', 'sagittal', 'coronal'].forEach(plane => {
    update(plane);
  });
}

function applyManualWindow() {
  manualWindowCenter = parseInt(document.getElementById('window-center').value);
  manualWindowWidth = parseInt(document.getElementById('window-width').value);
  
  // Обновляем все изображения
  ['axial', 'sagittal', 'coronal'].forEach(plane => {
    update(plane);
  });
}


    // Обновление среза
    async function update(plane, callback) {
      const idx = parseInt(document.getElementById(plane).value);
      const canvas = document.getElementById('canvas-' + plane);
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      drawCrossOnPlane(ctx, plane);
      if (callback) callback();
      };
      
     // img.src = `/api/dicom/reconstruct/${plane}?index=${idx}&t=${Date.now()}`;
      let url = `/api/dicom/reconstruct/${plane}?index=${idx}&mode=${currentMode}`;
      img.src = url + `&t=${Date.now()}`;
      
      if (currentMode === 'window') {
        url += `&window_center=${manualWindowCenter}&window_width=${manualWindowWidth}`;
      }
       

    }

    // Добавление метки по клику
 function addMarker(event, plane) {
  const canvas = event.target;
  const rect = canvas.getBoundingClientRect();
  const x = Math.round(event.clientX - rect.left);
  const y = Math.round(event.clientY - rect.top);

  // Получаем фактические размеры изображения на canvas
  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  const scaleX = 512 / imgWidth;
  const scaleY = 512 / imgHeight;

  const indices = {
    axial: parseInt(document.getElementById('axial').value),
    sagittal: parseInt(document.getElementById('sagittal').value),
    coronal: parseInt(document.getElementById('coronal').value),
  };

  let point3D;

  if (plane === 'axial') {
    point3D = { 
      x: x * scaleX, 
      y: y * scaleY, 
      z: indices.axial 
    };
  } else if (plane === 'sagittal') {
    point3D = {
      x: indices.sagittal,
      y: 512 - (x * scaleX),  // учитываем переворот изображения
      z: 512 - (y * scaleY)    // x на изображении становится z в объеме
    };
  } else if (plane === 'coronal') {
    point3D = {
      x: x * scaleX,
      y: indices.coronal,
      z: 512 - (y * scaleY)    // учитываем переворот изображения
    };
  }

  markers3D = [point3D];
  drawCrossOnSlices(point3D);
}

    // Рисование перекрестия на всех срезах
    function drawCrossOnSlices(point3D) {
      ['axial', 'sagittal', 'coronal'].forEach(plane => {
        update(plane, () => {
          const canvas = document.getElementById('canvas-' + plane);
          const ctx = canvas.getContext('2d');
          drawCrossOnPlane(ctx, plane, point3D);
        });
      });
    }

 // Рисование перекрестия на конкретном срезе
 function drawCrossOnPlane(ctx, plane, point3D = markers3D[0]) {
  if (!point3D) return;

  // Получаем размеры изображения на canvas
  const canvas = ctx.canvas;
  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  
  // Рассчитываем масштабные коэффициенты
  const scaleX = imgWidth / 512;
  const scaleY = imgHeight / 512;

  ctx.strokeStyle = 'lime';
  ctx.lineWidth = 1;
  ctx.beginPath();

  if (plane === 'axial') {
    // Для аксиальной плоскости просто используем x и y
    const yPos = point3D.y * scaleY;
    ctx.moveTo(0, yPos);
    ctx.lineTo(imgWidth, yPos);
    
    const xPos = point3D.x * scaleX;
    ctx.moveTo(xPos, 0);
    ctx.lineTo(xPos, imgHeight);
  } else if (plane === 'sagittal') {
    // Для сагиттальной плоскости
    const imgZ = (512 - point3D.z) * scaleY;
    ctx.moveTo(0, imgZ);
    ctx.lineTo(imgWidth, imgZ);

    const yPos = (512 - point3D.y) * scaleX;
    ctx.moveTo(yPos, 0);
    ctx.lineTo(yPos, imgHeight);
  } else if (plane === 'coronal') {
    // Для корональной плоскости
    const imgZ = (512 - point3D.z) * scaleY;
    ctx.moveTo(0, imgZ);
    ctx.lineTo(imgWidth, imgZ);
    
    const xPos = point3D.x * scaleX;
    ctx.moveTo(xPos, 0);
    ctx.lineTo(xPos, imgHeight);
  }

  ctx.stroke();
}
    // Назначаем события кликов и инициализация
    ['axial', 'sagittal', 'coronal'].forEach(plane => {
      document.getElementById('canvas-' + plane).addEventListener('click', e => addMarker(e, plane));
      update(plane);
    });
  </script>


<script>
 
async function handleUpload() {
    const fileInput = document.getElementById('dicom-upload');
    const statusDiv = document.getElementById('upload-status');
    const progressBar = document.getElementById('progress-bar');
    const fileInfoDiv = document.getElementById('file-info');
    const metadataContainer = document.getElementById('metadata-container');
    const metadataContent = document.getElementById('metadata-content');
    
    if (!fileInput.files.length) {
        statusDiv.textContent = 'Please select files';
        return;
    }

    statusDiv.textContent = 'Preparing upload...';
    progressBar.style.width = '0%';
    progressBar.textContent = '0%';
    metadataContainer.style.display = 'none'; // Скрываем метаданные перед загрузкой
    
    const formData = new FormData();
    let totalSize = 0;
    let fileCount = 0;
    
    // Добавляем файлы и считаем общий размер
    for (const file of fileInput.files) {
        const fileName = file.name;
        const parts = fileName.split('.');
        const hasExtension = parts.length > 1;
        const fileExt = hasExtension ? parts.pop().toLowerCase() : '';

        // Разрешаем файлы без расширения или с .dcm/.zip
        if (fileExt === '' || fileExt === 'dcm' || fileExt === 'zip') {
            formData.append('files', file);
            totalSize += file.size;
            fileCount++;
        }
    }
    
    if (fileCount === 0) {
        statusDiv.textContent = 'No valid DICOM or ZIP files selected';
        return;
    }
    
    fileInfoDiv.textContent = `Selected ${fileCount} files (${formatFileSize(totalSize)})`;
    statusDiv.textContent = 'Uploading...';
    
    try {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/dicom/upload');
        
        // Обработка прогресса загрузки
        xhr.upload.onprogress = function(e) {
            if (e.lengthComputable) {
                const percent = Math.round((e.loaded / e.total) * 100);
                progressBar.style.width = percent + '%';
                progressBar.textContent = percent + '%';
            }
        };
        
        xhr.onload = async function() {
            if (xhr.status === 200) {
                const result = JSON.parse(xhr.responseText);
                statusDiv.textContent = result.message;
                progressBar.style.width = '100%';
                progressBar.textContent = '100%';
                
                // Получаем информацию об объеме и обновляем слайдеры
                const volumeInfo = await fetch('/api/dicom/volume_info').then(r => r.json());
                console.log('Volume info:', volumeInfo);
                updateSliders(volumeInfo);

                // Получаем метаданные
                try {
                    const metadata = await fetch("/api/dicom/metadata").then(res => res.json());
                    
                    // Отображаем метаданные
                    metadataContainer.style.display = 'block';
                    metadataContent.innerHTML = `
                        <p><strong>Dimensions:</strong> Axial: ${metadata.shape.depth}, Coronal: ${metadata.shape.height}, Sagittal: ${metadata.shape.width}</p>
                        <p><strong>Spacing:</strong> X: ${metadata.spacing.x.toFixed(2)} mm, Y: ${metadata.spacing.y.toFixed(2)} mm, Z: ${metadata.spacing.z.toFixed(2)} mm</p>

                        <p><strong>Study UID:</strong> ${metadata.study_info.StudyInstanceUID}</p>
                        <p><strong>Series UID:</strong> ${metadata.study_info.SeriesInstanceUID}</p>
                        <p><strong>Modality:</strong> ${metadata.study_info.Modality}</p>
                        <p><strong>Date:</strong> ${metadata.study_info.StudyDate}</p>

                        <p><strong>Patient:</strong> ${metadata.study_info.PatientName}</p>
                        <p><strong>Birth Date:</strong> ${metadata.study_info.PatientBirthDate}</p>

                        <p><strong>Manufacturer:</strong> ${metadata.study_info.Manufacturer}</p>
                        <p><strong>Model:</strong> ${metadata.study_info.DeviceModel}</p>

                        <p><strong>KVP:</strong> ${metadata.study_info.KVP}</p>
                        <p><strong>Current (mA):</strong> ${metadata.study_info.XRayTubeCurrent}</p>
                        <p><strong>Exposure (mAs):</strong> ${metadata.study_info.Exposure}</p>
                      `;
                    
                } catch (error) {
                    console.error("Error fetching metadata:", error);
                    metadataContent.innerHTML = "<p>Failed to load metadata</p>";
                }
                
                // Перезагружаем изображения
                ['axial', 'sagittal', 'coronal'].forEach(update);

            } else {
                statusDiv.textContent = `Error: ${xhr.statusText}`;
                progressBar.style.background = '#f44336';
            }
        };
        
        xhr.onerror = function() {
            statusDiv.textContent = 'Upload failed';
            progressBar.style.background = '#f44336';
        };
        
        xhr.send(formData);
    } catch (error) {
        statusDiv.textContent = `Error: ${error.message}`;
        progressBar.style.background = '#f44336';
    }
}

function updateSliders(volumeInfo) {
  // Используем slices вместо depth, если shape отсутствует
  const depth = volumeInfo.shape?.depth ?? volumeInfo.slices;
  const width = volumeInfo.shape?.width ?? volumeInfo.width;
  const height = volumeInfo.shape?.height ?? volumeInfo.height;

  // Устанавливаем максимальные значения для каждого ползунка
  document.getElementById('axial').max = Math.max(0, depth - 1);
  document.getElementById('sagittal').max = Math.max(0, width - 1);
  document.getElementById('coronal').max = Math.max(0, height - 1);
  
  // Устанавливаем средние значения
  document.getElementById('axial').value = Math.floor(depth / 2);
  document.getElementById('sagittal').value = Math.floor(width / 2);
  document.getElementById('coronal').value = Math.floor(height / 2);
  
  // Обновляем отображаемые значения
  updateSliderValue('axial');
  updateSliderValue('sagittal');
  updateSliderValue('coronal');
}

// Функция для обновления отображаемого значения ползунка
function updateSliderValue(plane) {
  const slider = document.getElementById(plane);
  const valueDisplay = slider.nextElementSibling; // Предполагаем, что следующий элемент - это span для значения
  if (valueDisplay && valueDisplay.classList.contains('dcm-range-value')) {
    valueDisplay.textContent = slider.value;
  }
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
  </script>
  

</body>
</html>
