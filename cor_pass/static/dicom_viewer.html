
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="/static/favicon.png">
  <meta charset="UTF-8">
  <title>DICOM Viewer</title>
 
<link rel="stylesheet" type="text/css" href="/static/dicom_viewer.css">
<link rel="stylesheet" type="text/css" href="/static/styles.css">
<link rel="stylesheet" type="text/css" href="/static/modal.css">
</head>
<body>

  <div id="Dicom_upload_modal" class="modal" style="display: block;">

    <div class="modal-header">     
      <div class="modal-buttons">
          <button class="modal-button close" data-action="close" id="closeDicom_upload_modal">✖</button>
      </div>       
      <h3 style="margin-top:30; color:#291161;font-size: 17px;">Upload Medical Files</h3>
    </div>  
      
    <div class="dicom-upload-container">
      <input type="file" id="dicom-upload" accept=".zip,.dcm" multiple>
      <button onclick="handleUpload()">Upload DICOM files</button>
      <div class="dicom-progress-container">

          <div class="dicom-progress-bar" id="progress-bar">0%</div>
      </div>
      <div class="file-info" id="file-info"></div>
      <div id="upload-status"></div>

      <div class="svs-preview-container" id="svs-preview-container" style="display: none;">
        <h3 style="margin-top:5px;margin-bottom:5px;  color: #7527B2; font-size: 15px;">SVS Preview</h3>
        <img id="svs-thumbnail" src="" alt="SVS Thumbnail" style="max-width: 512px; border: 1px solid #ccc; cursor: pointer;" onclick="openFullscreenSVSFromThumbnail()" />
      </div>
    </div>
    
  </div>


  <div class="viewer hidden" id="DcmViewerFrame">
    <div class="view">
      <label class="label-padded">Coronal</label> 
      <canvas id="canvas-coronal" width="512" height="512"></canvas>   
      <div class="dcm-range-container">
        <input type="range" id="coronal" min="0" max="100" value="50" 
               oninput="update('coronal'); updateSliderValue('coronal')">
        <span class="dcm-range-value">50</span>
      </div>
    </div>
    
    <div class="view">
      <label class="label-padded">Sagittal</label>
      <canvas id="canvas-sagittal" width="512" height="512"></canvas>     
      <div class="dcm-range-container">
        <input type="range" id="sagittal" min="0" max="100" value="50" 
               oninput="update('sagittal'); updateSliderValue('sagittal')">
        <span class="dcm-range-value">50</span>
      </div>
    </div>
   
    <div class="view">
      <label class="label-padded">Axial</label>
      <canvas id="canvas-axial" width="512" height="512"></canvas>
      <div class="dcm-range-container">
        <input type="range" id="axial" min="0" max="100" value="50" 
               oninput="update('axial'); updateSliderValue('axial')">
        <span class="dcm-range-value">50</span>
      </div>
    </div>

    <div class="dicom-upload-container">
  
      <div class="metadata-container" id="metadata-container" style="display: none;">
        <h3 style="margin-top:5px;margin-bottom:5px;  color: #7527B2; font-size: 15px;">DICOM Metadata</h3>
        <div id="metadata-content"></div>
      </div>

      <div class="viewer-controls" id="viewer-controls">
        <label>View Mode:
          <select id="view-mode" onchange="updateViewMode()">
            <option value="auto">Auto (Window Level)</option>
            <option value="window">Manual Window Level</option>
            <option value="raw">Raw Data</option>
          </select>
        </label>
        
        <div id="window-controls" style="display: none; margin-top: 10px;">
          <label>Window Center: <input type="range" id="window-center" min="0" max="3000" value="50" step="1"></label>
          <label>Window Width: <input type="range" id="window-width" min="0" max="3000" value="400" step="1"></label>
          <button onclick="applyManualWindow()">Apply</button>
        </div>
      </div>
  </div>

  <div id="svs-fullscreen-viewer" class="svs-fullscreen-viewer" style="display: none;">
    <div class="svs-viewer-container">
        <div class="svs-image-container">
            <img id="svs-fullscreen-image" class="svs-main-image"/>
            <div class="svs-toolbar">
                <button class="tool-btn zoom-in" title="Zoom In">+</button>
                <button class="tool-btn zoom-out" title="Zoom Out">-</button>
                <button class="tool-btn pan" title="Pan">↔</button>
                <button class="tool-btn close-btn" title="Close">×</button>
            </div>
        </div>
        <div class="svs-metadata-panel">
            <div class="metadata-header">
                <h3>Slide Metadata</h3>
                <button class="collapse-btn">≡</button>
            </div>
            <div id="svs-metadata-content" class="metadata-content"></div>
        </div>
    </div>
</div>
</div>

  <script src="/static/translation.js"></script>  
  <script src="/static/general_fun.js"></script> 
  <script src="/static/dicom_viewer.js"></script>  
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="/static/SVS_Viewer/openseadragon.min.js"></script>
  
  <script>
    let markers3D = [];

    let currentMode = 'auto';
    let manualWindowCenter = 50;
    let manualWindowWidth = 400;

    function updateViewMode() {
  currentMode = document.getElementById('view-mode').value;
  
  // Показываем/скрываем ручные контролы window level
  const windowControls = document.getElementById('window-controls');
  windowControls.style.display = currentMode === 'window' ? 'block' : 'none';
  
  // Обновляем все изображения
  ['axial', 'sagittal', 'coronal'].forEach(plane => {
    update(plane);
  });
}

function applyManualWindow() {
  manualWindowCenter = parseInt(document.getElementById('window-center').value);
  manualWindowWidth = parseInt(document.getElementById('window-width').value);
  
  // Обновляем все изображения
  ['axial', 'sagittal', 'coronal'].forEach(plane => {
    update(plane);
  });
}


async function update(plane, callback) {
    const idx = parseInt(document.getElementById(plane).value);
    const canvas = document.getElementById('canvas-' + plane);
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    // Получаем токен из localStorage или URL
    const token = localStorage.getItem('authToken') || 
                  new URLSearchParams(window.location.search).get('access_token');

    img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        drawCrossOnPlane(ctx, plane);
        // Добавляем проверку, является ли callback функцией перед вызовом
        if (callback && typeof callback === 'function') {
            callback();
        }
    };

    // Создаем URL с параметрами
    const params = new URLSearchParams({
        index: idx,
        mode: currentMode,
        t: Date.now()
    });

    if (currentMode === 'window') {
        params.append('window_center', manualWindowCenter);
        params.append('window_width', manualWindowWidth);
    }

    try {
        const response = await fetch(`/api/dicom/reconstruct/${plane}?${params.toString()}`, {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const blob = await response.blob();
        img.src = URL.createObjectURL(blob);
    } catch (error) {
        console.error('Error loading DICOM image:', error);
        // Обработка ошибок (например, показать сообщение)
        if (error.message.includes('401')) {
            alert('Session expired. Please login again.');
            window.location.href = '/';
        }
    }
}

    // Добавление метки по клику
 function addMarker(event, plane) {
  const canvas = event.target;
  const rect = canvas.getBoundingClientRect();
  const x = Math.round(event.clientX - rect.left);
  const y = Math.round(event.clientY - rect.top);

  // Получаем фактические размеры изображения на canvas
  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  const scaleX = 512 / imgWidth;
  const scaleY = 512 / imgHeight;

  const indices = {
    axial: parseInt(document.getElementById('axial').value),
    sagittal: parseInt(document.getElementById('sagittal').value),
    coronal: parseInt(document.getElementById('coronal').value),
  };

  let point3D;

  if (plane === 'axial') {
    point3D = { 
      x: x * scaleX, 
      y: y * scaleY, 
      z: indices.axial 
    };
  } else if (plane === 'sagittal') {
    point3D = {
      x: indices.sagittal,
      y: 512 - (x * scaleX),  // учитываем переворот изображения
      z: 512 - (y * scaleY)    // x на изображении становится z в объеме
    };
  } else if (plane === 'coronal') {
    point3D = {
      x: x * scaleX,
      y: indices.coronal,
      z: 512 - (y * scaleY)    // учитываем переворот изображения
    };
  }

  markers3D = [point3D];
  drawCrossOnSlices(point3D);
}

    // Рисование перекрестия на всех срезах
    function drawCrossOnSlices(point3D) {
      ['axial', 'sagittal', 'coronal'].forEach(plane => {
        update(plane, () => {
          const canvas = document.getElementById('canvas-' + plane);
          const ctx = canvas.getContext('2d');
          drawCrossOnPlane(ctx, plane, point3D);
        });
      });
    }

 // Рисование перекрестия на конкретном срезе
 function drawCrossOnPlane(ctx, plane, point3D = markers3D[0]) {
  if (!point3D) return;

  // Получаем размеры изображения на canvas
  const canvas = ctx.canvas;
  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  
  // Рассчитываем масштабные коэффициенты
  const scaleX = imgWidth / 512;
  const scaleY = imgHeight / 512;

  ctx.strokeStyle = 'lime';
  ctx.lineWidth = 1;
  ctx.beginPath();

  if (plane === 'axial') {
    // Для аксиальной плоскости просто используем x и y
    const yPos = point3D.y * scaleY;
    ctx.moveTo(0, yPos);
    ctx.lineTo(imgWidth, yPos);
    
    const xPos = point3D.x * scaleX;
    ctx.moveTo(xPos, 0);
    ctx.lineTo(xPos, imgHeight);
  } else if (plane === 'sagittal') {
    // Для сагиттальной плоскости
    const imgZ = (512 - point3D.z) * scaleY;
    ctx.moveTo(0, imgZ);
    ctx.lineTo(imgWidth, imgZ);

    const yPos = (512 - point3D.y) * scaleX;
    ctx.moveTo(yPos, 0);
    ctx.lineTo(yPos, imgHeight);
  } else if (plane === 'coronal') {
    // Для корональной плоскости
    const imgZ = (512 - point3D.z) * scaleY;
    ctx.moveTo(0, imgZ);
    ctx.lineTo(imgWidth, imgZ);
    
    const xPos = point3D.x * scaleX;
    ctx.moveTo(xPos, 0);
    ctx.lineTo(xPos, imgHeight);
  }

  ctx.stroke();
}
    // Назначаем события кликов и инициализация
    ['axial', 'sagittal', 'coronal'].forEach(plane => {
      document.getElementById('canvas-' + plane).addEventListener('click', e => addMarker(e, plane));
      update(plane);
    });
  </script>


<script>
 
 handleUpload();

function updateSliders(volumeInfo) {
  // Используем slices вместо depth, если shape отсутствует
  const depth = volumeInfo.shape?.depth ?? volumeInfo.slices;
  const width = volumeInfo.shape?.width ?? volumeInfo.width;
  const height = volumeInfo.shape?.height ?? volumeInfo.height;

  // Устанавливаем максимальные значения для каждого ползунка
  document.getElementById('axial').max = Math.max(0, depth - 1);
  document.getElementById('sagittal').max = Math.max(0, width - 1);
  document.getElementById('coronal').max = Math.max(0, height - 1);
  
  // Устанавливаем средние значения
  document.getElementById('axial').value = Math.floor(depth / 2);
  document.getElementById('sagittal').value = Math.floor(width / 2);
  document.getElementById('coronal').value = Math.floor(height / 2);
  
  // Обновляем отображаемые значения
  updateSliderValue('axial');
  updateSliderValue('sagittal');
  updateSliderValue('coronal');
}

// Функция для обновления отображаемого значения ползунка
function updateSliderValue(plane) {
  const slider = document.getElementById(plane);
  const valueDisplay = slider.nextElementSibling; 
  if (valueDisplay && valueDisplay.classList.contains('dcm-range-value')) {
    valueDisplay.textContent = slider.value;
  }
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
  </script>
 <script> 
 document.addEventListener('DOMContentLoaded', () => { 
  makeModalDraggable('Dicom_upload_modal');
  document.getElementById('DcmViewerFrame').classList.add('hidden');

});

function showMainContent() {
  document.getElementById('main-content').style.display = 'block';
}
</script>

</body>
</html>
